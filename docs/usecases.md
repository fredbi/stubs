# Use cases for stubs

The stubs package is intended to support the following use cases:

1. Generate unit test cases for code generated by go-swagger, especially validation code
2. Generate test cases for API servers and clients
3. Generate realistic examples

## Supported swagger 2.0 constructs

- parameter 
- header 
- response
- schema, including support for:
  - [] AllOf 
  - [] Not
  - [] additionalProperties
  - [] patternProperties 
  - [] additionalItems

Formated strings and numbers support go-openapi/strfmt formats, including:
  - [] binary (strfmt.Base64)
  - [] bsonobjectid

The "file" datatype is not supported at the moment.

The generation assumes the provide swagger spec is valid. 

Warnings regarding test case (2): 
- stubs is not concerned about security definitions and credentials
- stubs generates values independently for each parameter, or response: it does not know about consistent sets of values beyond validation constraints, let alone 
  proper chaining of request with responses.

## Sample applications for stubs

- process a spec to include examples 
- generate fixtures for codegen unit testing
- generate fixtures for API server benchmarking
- ...

# Reproducible stubs 

Generated stubs may be regenerated using the same initial seed. 

There are two seeding modes to run the stubs generator: 

- AutoSeed: reseeds itself based on current timestamp 
- SetSeed: generation occurs with a single seed, provided by the caller

The package uses a default seeder to carry on this task. Alternate seeders might be provided.

This also allows for unit testing this very package...

# Setting generation goals 

Goals select the general use case and allow for fine tuning of the sample generation.

We use GenerateMode and StubMode flags to define goals.

Stubmode is used to tune individually every single generated value.

GenerateMode sets general directives and may define StubMode autonomously according to the generation goal.

## GenerateMode

target:
- unitTest: any value value may be produced, not necessarily a realistic definevalue. 
  By default in the UnitTest mode, non-formated strings are loren ipsums, numbers, dates and times may be very small or very large
- examples: the generator attempts to figure out realistic values to be used as examples

GenerateMode accepts arguments to further specify the expected generation: 

args:
- valid:    all generated values are valid. This is the default.
  - count: number of samples to be generated. May be zero to get only default, examples, edge cases or validation checks. Default is 1.
- invalid:  all generated values are invalid, with failures chosen at random.
  - count: number of samples to be generated. Default is 1.
- skipTilting: tilting rules are omitted (only applies to invalid values). Default is true in unit test mode and false in example mode.
- skipFuzzying: fuzzying rules are omitted
- withTilting: add tilted invalid values, with failures chosen at random. This forces a tilting strategy on a new set of values.
  - count: number of tilted samples to be generated. Default is 1.
- withValidationCheck: for each validation, an invalid value against this validation is generated (e.g. if min and max are specified, we have one value below min and one value above max)
   - count: this sets a limit on the count of generated values. If you have n validations, that makes n generated values. With the limit set, validations are checked width-first (outermost validations come first)
- withAllValidationChecks: all combinations of failed validations are generated. This includes one valid value and single failure from withValidation.
   - count: this sets a limit on the count of generated values. If you have n validations, that makes 2^n generated values, which may raise quickly when nesting schema structures. With the limit set, validations are checked width-first (outermost validations come first)
- withDefault: add default value to sample values (not included in "count"). This simulates a user providing exactly the same value as the default. Since defaults may be set at different levels of the structure, a new value is generated for each applicable default.
- withExample: add example value to sample values (not included in "count"), whenever applicable. Examples are assumed valid, but may be invalid.
   - tiltDefault: constructs invalid values by tilting default
   - tiltExample: constructs invalid values by tilting examples  
   - count: number of title
- withEdgeCase:
    - standard: standard preconfigured edge cases (e.g. boundary value for min constraint with boundary included, Feb 29th dates for date types, ...)
    - value: a customizable value added as an edge case. May be any value, array or object. Severa values may be specified.
- max: an upper limit on number generation (floats, ints, ...). By default, the full range of the data type is used.
- min: a lower limit on number generation.
- precision: rounding specification for floats
- multipleOf: a multiple specification for numbers
- length:
  - on string values: an upper limit on string size, to avoid long texts being unwittingly generated
  - on array values: an upper limit on the number of generated items
  - on additionalProperties: an upper limit on the number of generated additionalProperties
  - on patternProperties: an upper limit on the number of generated patternProperties
- words: a limit on the number of words in generated texts, paragraphs and sentences
- lang: specifies the target language(s) for strings and text. 
  - [lang]
  - all: special value to tell the generator to pick text at random from all supported languages

This sets an overall target for all generations. For every single spec object, you may hint further and override global settings on a case by case basis.

# Hinting

The `x-datagen` extension may be used in the swagger spec to hint the stubs generator.

Examples:
``` 
parameters:
    phone:
        in: query 
        required: true
        type: string
        x-datagen:
          name: mobile
```
will generate a mobile phone number for query parameter "phone".

``` 
parameters:
    price:
        in: query 
        required: true
        type: string
        x-datagen:
          name: float
```
will generate float numbers for the price parameter. 
It might be not realistic to have 3.1344344E35 as a price, but it is a valid value...

`x-datagen` accepts args to further hint the generator. 
All Args accepted by GenerateMode or StubMode may be used here to locally override generation options. 

Example:
``` 
parameters:
    vat:
        in: query 
        required: true
        type: number
        x-datagen:
          args:
            min: 100
            max: 10000
            
```
will generate floats between 100 and 10000. 
Again, it might not be realistic to have prices such as 503.14561434566...

Some generators are already configured to suit some targeted usage.

Example: 
``` 
parameters:
    price:
        in: query 
        required: true
        type: string
        x-datagen:
          name: small-amounts
```
and you get more realistic values like 3.23, 104.30...

## x-datagen args

- name: overrides the generator's name

Supported args, not already mentioned in the GenerateMode section:
- args:

# Fuzzying

The generation takes basic decisions based on type and available validation constraints.
Obviously, this does not work well when the goal is to generate realistic samples for your data.
Of course, everyhing may be fine-tuned by using the x-datagen extension.
But this is tedious work on large specs. 

We introduce fuzzying as a way to carry on some of the guesswork when deciding which kind of fake value would best match expectations. 
Fuzzying relies on names, titles and description to look for recognizable keywords, then elects an adequate random generator.

Examples for the above samples:
- with name "price", the fuzzying guesses that it is not some arbitrary float to be generated, but a decimal between 0 and 1,000,000 (max overrides this limit).
- with a description such as "The item price expressed in USD. Items are sold at a low price", fuzzying rules should guess that we want to generate small-amount values (so between 0 and 1,000).

Fuzzying also works for non-strings data:
- a date field named "birthday" would hint toward the birthdate value generator (hence dates are not in the future and only in a recent past)
- a datetime named "timestamp" or described as "The update date" would generate a recent datetime value. Further, edge cases with this guess would add 01/01/1970 to the generated value

# Tilting

Tilting is a strategy to generate invalid values, by tilting a valid value just enough so it becomes invalid.
This generates interesting test cases since values are supposed to be "almost" valid but actually are not.

Tilting strategies depend on validations. 

Examples:
- tilting on max will generate a value at or slightly above the lowest invalid value 
- tilting on regexp will change the smallest number of characters in a string so the regexp no more matches
- tilting on enum will slightly modify a valid value and make it invalid
- ...

Options skipTilting and withTilting tune the generator behavior regarding tilting.
